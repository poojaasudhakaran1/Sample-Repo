name: Poll GitHub Project (v2) and Create Jira Epics

on:
  schedule:
    - cron: "*/2 * * * *" # every 5 minutes
  workflow_dispatch: # allow manual runs for testing

jobs:
  sync-project-to-jira:
    runs-on: ubuntu-latest
    env:
      REPO_OWNER: poojaasudhakaran1 # <-- set this
      REPO_NAME: Sample-Repo # <-- set this
      PROJECT_NUMBER: 1 # <-- set this (project number shown in URL)
      JIRA_PROJECT_KEY: TEST # <-- set this (Jira project key e.g. ENG)
      JIRA_EPIC_ISSUE_TYPE: Epic
      JIRA_EPIC_NAME_FIELD: "customfield_10011" # optional: e.g. customfield_10011 (leave empty if not needed)
      JIRA_BASE_URL: ${{ secrets.JIRA_BASE_URL }}
      JIRA_EMAIL: ${{ secrets.JIRA_EMAIL }}
      JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
      GH_TOKEN: ${{ secrets.GH_TOKEN }}
      JIRA_KEY_FIELD_NAME: "Jira Key" # name of the Project text field to write the key to
    steps:

      - name: Checkout (no code used, but good for logs)
        uses: actions/checkout@v4

      - name: Query GitHub Project: find projectId, fieldId, and unsynced items
        id: find_items
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.GH_TOKEN }}
          script: |
            const owner = process.env.REPO_OWNER;
            const repo = process.env.REPO_NAME;
            const projectNumber = parseInt(process.env.PROJECT_NUMBER, 10);
            const jiraKeyFieldName = process.env.JIRA_KEY_FIELD_NAME;

            const q = `
              query($owner:String!, $repo:String!) {
                repository(owner:$owner, name:$repo) {
                  projectsV2(first: 20) {
                    nodes {
                      id
                      number
                      title
                      fields(first: 50) {
                        nodes {
                          id
                          name
                        }
                      }
                      items(first: 100) {
                        nodes {
                          id
                          content {
                            ... on Issue { id number url title body }
                            ... on DraftIssue { title body }
                          }
                          fieldValues(first: 50) {
                            nodes {
                              ... on ProjectV2ItemFieldTextValue {
                                field { id name }
                                text
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            `;
            const res = await github.graphql(q, { owner, repo });

            const projects = res.repository.projectsV2.nodes || [];
            const project = projects.find(p => p.number === projectNumber);
            if (!project) throw new Error(`Project number ${projectNumber} not found in ${owner}/${repo}`);

            // find Jira Key field id
            const fieldNode = project.fields.nodes.find(f => f.name === jiraKeyFieldName);
            if (!fieldNode) throw new Error(`Project field "${jiraKeyFieldName}" not found on project ${projectNumber}`);
            const jiraFieldId = fieldNode.id;

            // collect unsynced items
            const unsynced = [];
            for (const item of project.items.nodes) {
              const already = item.fieldValues.nodes.some(f => f.field.name === jiraKeyFieldName && f.text && f.text.trim().length > 0);
              const title = item.content?.title || null;
              if (!already && title) {
                unsynced.push({
                  itemId: item.id,
                  title,
                  body: item.content?.body || "",
                });
              }
            }

            console.log(`Project id: ${project.id}, Jira key field id: ${jiraFieldId}, unsynced items: ${unsynced.length}`);
            return {
              projectId: project.id,
              jiraFieldId,
              unsyncedItems: unsynced
            };

      - name: Create Jira Epics and update GitHub Project items
        if: steps.find_items.outputs.unsyncedItems != '[]'
        run: |
          set -euo pipefail
          echo "Start creating Jira epics for unsynced items..."

          PROJECT_ID="$(jq -r '.projectId' <<< '${{ toJson(steps.find_items.outputs) }}')"
          JIRA_FIELD_ID="$(jq -r '.jiraFieldId' <<< '${{ toJson(steps.find_items.outputs) }}')"
          UNSYNCED_JSON="$(jq -c '.unsyncedItems[]' <<< '${{ toJson(steps.find_items.outputs) }}' || true)"

          echo "Project ID: $PROJECT_ID"
          echo "Jira field ID for writing key: $JIRA_FIELD_ID"

          if [ -z "$UNSYNCED_JSON" ]; then
            echo "No unsynced items found."
            exit 0
          fi

          for ITEM_JSON in $UNSYNCED_JSON; do
            ITEM_ID=$(jq -r '.itemId' <<< "$ITEM_JSON")
            TITLE=$(jq -r '.title' <<< "$ITEM_JSON")
            BODY=$(jq -r '.body' <<< "$ITEM_JSON")

            echo "Processing item $ITEM_ID : $TITLE"

            # Build Jira payload. If JIRA_EPIC_NAME_FIELD is set, include it.
            if [ -n "${{ env.JIRA_EPIC_NAME_FIELD }}" ] && [ "${{ env.JIRA_EPIC_NAME_FIELD }}" != " " ]; then
              JIRA_PAYLOAD=$(jq -n \
                --arg proj "$JIRA_PROJECT_KEY" \
                --arg summary "$TITLE" \
                --arg description "$BODY" \
                --arg epiField "${{ env.JIRA_EPIC_NAME_FIELD }}" \
                '{
                  fields: (
                    {
                      project: { key: $proj },
                      summary: $summary,
                      description: $description,
                      issuetype: { name: "Epic" }
                    } + { ($epiField): $summary }
                  )
                }')
            else
              JIRA_PAYLOAD=$(jq -n \
                --arg proj "$JIRA_PROJECT_KEY" \
                --arg summary "$TITLE" \
                --arg description "$BODY" \
                '{
                  fields: {
                    project: { key: $proj },
                    summary: $summary,
                    description: $description,
                    issuetype: { name: "Epic" }
                  }
                }')
            fi

            echo "Creating Jira Epic..."
            RESPONSE=$(curl -s -u "${JIRA_EMAIL}:${JIRA_API_TOKEN}" \
              -X POST \
              -H "Content-Type: application/json" \
              --data "$JIRA_PAYLOAD" \
              "${JIRA_BASE_URL}/rest/api/3/issue")

            JIRA_KEY=$(echo "$RESPONSE" | jq -r .key)
            if [ "$JIRA_KEY" = "null" ] || [ -z "$JIRA_KEY" ]; then
              echo "Failed to create Jira issue. Response:"
              echo "$RESPONSE"
              continue
            fi
            echo "Created Jira epic: $JIRA_KEY"

            # Now update the GitHub Project item field via GraphQL
            echo "Updating GitHub Project item $ITEM_ID field $JIRA_FIELD_ID with $JIRA_KEY"

            MUTATION='mutation UpdateField($input: UpdateProjectV2ItemFieldValueInput!) { updateProjectV2ItemFieldValue(input: $input) { projectV2Item { id } } }'
            VARIABLES=$(jq -n \
              --arg projectId "$PROJECT_ID" \
              --arg itemId "$ITEM_ID" \
              --arg fieldId "$JIRA_FIELD_ID" \
              --arg jiraKey "$JIRA_KEY" \
              '{ input: { projectId: $projectId, itemId: $itemId, fieldId: $fieldId, value: { text: $jiraKey } } }')

            GITHUB_RESPONSE=$(curl -s -X POST https://api.github.com/graphql \
              -H "Authorization: Bearer ${GH_TOKEN}" \
              -H "Content-Type: application/json" \
              -d "$(jq -n --arg q "$MUTATION" --argjson v "$VARIABLES" '{query: $q, variables: $v}')" )

            echo "GitHub response: $GITHUB_RESPONSE"
            echo "Done for item $ITEM_ID"

            # small delay to be polite to APIs
            sleep 1
          done

          echo "All done."
        env:
          JIRA_BASE_URL: ${{ env.JIRA_BASE_URL }}
          JIRA_EMAIL: ${{ env.JIRA_EMAIL }}
          JIRA_API_TOKEN: ${{ env.JIRA_API_TOKEN }}
          GH_TOKEN: ${{ env.GH_TOKEN }}
          JIRA_PROJECT_KEY: ${{ env.JIRA_PROJECT_KEY }}
