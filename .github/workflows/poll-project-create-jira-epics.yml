name: Poll GitHub Project (v2) and Create Jira Epics

on:
  schedule:
    - cron: "*/10 * * * *" # every 5 minutes
  workflow_dispatch: # allow manual runs for testing

jobs:
  sync-project-to-jira:
    runs-on: ubuntu-latest
    env:
      REPO_OWNER: poojaasudhakaran1 # <-- set this
      REPO_NAME: Sample-Repo # <-- set this
      PROJECT_NUMBER: 1 # <-- set this (project number shown in URL)
      JIRA_PROJECT_KEY: TEST # <-- set this (Jira project key e.g. ENG)
      JIRA_EPIC_ISSUE_TYPE: Epic
      JIRA_EPIC_NAME_FIELD: "customfield_10011" # optional: e.g. customfield_10011 (leave empty if not needed)
      JIRA_BASE_URL: ${{ secrets.JIRA_BASE_URL }}
      JIRA_EMAIL: ${{ secrets.JIRA_EMAIL }}
      JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
      GH_TOKEN: ${{ secrets.GH_TOKEN }}
      JIRA_KEY_FIELD_NAME: "Jira Key" # name of the Project text field to write the key to
    steps:

      - name: Checkout (no code used, but good for logs)
        uses: actions/checkout@v4

      - name: "Query GitHub Project: find projectId, fieldId, and unsynced items"
        id: find_items
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.GH_TOKEN }}
          script: |
            const fs = require('fs');
            const owner = process.env.REPO_OWNER;
            const repo = process.env.REPO_NAME;
            const projectNumber = parseInt(process.env.PROJECT_NUMBER, 10);
            const jiraKeyFieldName = process.env.JIRA_KEY_FIELD_NAME;

            const q = `
              query($owner:String!, $repo:String!) {
                repository(owner:$owner, name:$repo) {
                  projectsV2(first: 20) {
                    nodes {
                      id
                      number
                      title
                      fields(first: 50) {
                        nodes {
                            ... on ProjectV2FieldCommon {
                                id
                                name
                            }
                        }
                      }
                      items(first: 100) {
                        nodes {
                          id
                          content {
                            ... on Issue { id number url title body }
                            ... on DraftIssue { title body }
                          }
                          fieldValues(first: 50) {
                            nodes {
                              ... on ProjectV2ItemFieldTextValue {
                                field { 
                                    ... on ProjectV2FieldCommon {
                                        id
                                        name
                                    }
                                }
                                text
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            `;
            const res = await github.graphql(q, { owner, repo });

            const projects = res.repository.projectsV2.nodes || [];
            const project = projects.find(p => p.number === projectNumber);
            if (!project) throw new Error(`Project number ${projectNumber} not found in ${owner}/${repo}`);

            // find Jira Key field id
            const fieldNode = project.fields.nodes.find(f => f.name === jiraKeyFieldName);
            if (!fieldNode) throw new Error(`Project field "${jiraKeyFieldName}" not found on project ${projectNumber}`);
            const jiraFieldId = fieldNode.id;

            // collect unsynced items
            const unsynced = [];
            for (const item of project.items.nodes) {
              const already = item.fieldValues.nodes.some(f => f?.field?.name === jiraKeyFieldName && typeof f.text === 'string' && f.text.trim().length > 0);
              const title = item.content?.title || null;
              if (!already && title) {
                unsynced.push({
                  itemId: item.id,
                  title,
                  body: item.content?.body || "",
                });
              }
            }

            console.log(`Project id: ${project.id}, Jira key field id: ${jiraFieldId}, unsynced items: ${unsynced.length}`);
            const unsyncedJson = JSON.stringify(unsynced);
            const unsyncedB64 = Buffer.from(unsyncedJson,'utf8').toString('base64');
            
            core.setOutput("projectId",project.id);
            core.setOutput("jiraFieldId",jiraFieldId);
            core.setOutput("unsyncedItemsBase64",unsyncedB64);
            
            return {
              projectId: project.id,
              jiraFieldId,
              unsyncedItemsBase64: unsyncedB64
            };

      - name: Create Jira Epics and update GitHub Project items
        if: steps.find_items.outputs.unsyncedItemsBase64 != '[]'
        run: |
          set -euo pipefail
          echo "Start creating Jira epics for unsynced items..."

          PROJECT_ID="${{ steps.find_items.outputs.projectId }}"
          JIRA_FIELD_ID="${{ steps.find_items.outputs.jiraFieldId }}"
          UNSYNCED_B64='${{ steps.find_items.outputs.unsyncedItemsBase64 }}'

          echo "Project ID: $PROJECT_ID"
          echo "Jira field ID for writing key: $JIRA_FIELD_ID"
          echo "Base64 length: ${#UNSYNCED_B64}"
          
           # Try to decode with base64 --decode (GNU), fallback to -D (BSD/mac) or python
            if decoded=$(printf '%s' "$UNSYNCED_B64" | base64 --decode 2>/dev/null); then
                UNSYNCED_RAW="$decoded"
            elif decoded=$(printf '%s' "$UNSYNCED_B64" | base64 -D 2>/dev/null); then
                UNSYNCED_RAW="$decoded"
            else
                UNSYNCED_RAW=$(python3 - <<PY
                import sys, base64
                b = base64.b64decode(sys.stdin.read().strip())
                sys.stdout.write(b.decode('utf8'))
                PY
                )
            fi
            
            # quick preview (limit output)
            echo "Preview of decoded JSON (first 400 chars):"
            printf '%s\n' "$UNSYNCED_RAW" | head -c 400; echo
            
                # Validate JSON before iterating
            echo "$UNSYNCED_RAW" | jq . >/dev/null 2>&1 || {
                echo "ERROR: Decoded JSON is invalid. Dumping full content for debug:"
                echo "$UNSYNCED_RAW"
                exit 1
            }
          
          mapfile -t ITEMS < <(echo "$UNSYNCED_RAW" | jq -c '.[]?')

          if [ "${#ITEMS[@]}" -eq 0 ]; then
            echo "No unsynced items found."
            exit 0
          fi

          for ITEM_JSON in $ITEMS; do
            ITEM_ID=$(jq -r '.itemId' <<< "$ITEM_JSON")
            TITLE=$(jq -r '.title' <<< "$ITEM_JSON")
            BODY=$(jq -r '.body' <<< "$ITEM_JSON")

            echo "Processing item $ITEM_ID : $TITLE"

            # Build Jira payload. If JIRA_EPIC_NAME_FIELD is set, include it.
            if [ -n "${{ env.JIRA_EPIC_NAME_FIELD }}" ] && [ "${{ env.JIRA_EPIC_NAME_FIELD }}" != " " ]; then
              JIRA_PAYLOAD=$(jq -n \
                --arg proj "$JIRA_PROJECT_KEY" \
                --arg summary "$TITLE" \
                --arg description "$BODY" \
                --arg epiField "${{ env.JIRA_EPIC_NAME_FIELD }}" \
                '{
                  fields: (
                    {
                      project: { key: $proj },
                      summary: $summary,
                      description: $description,
                      issuetype: { name: "Epic" }
                    } + { ($epiField): $summary }
                  )
                }')
            else
              JIRA_PAYLOAD=$(jq -n \
                --arg proj "$JIRA_PROJECT_KEY" \
                --arg summary "$TITLE" \
                --arg description "$BODY" \
                '{
                  fields: {
                    project: { key: $proj },
                    summary: $summary,
                    description: $description,
                    issuetype: { name: "Epic" }
                  }
                }')
            fi

            echo "Creating Jira Epic..."
            RESPONSE=$(curl -s -u "${JIRA_EMAIL}:${JIRA_API_TOKEN}" \
              -X POST \
              -H "Content-Type: application/json" \
              --data "$JIRA_PAYLOAD" \
              "${JIRA_BASE_URL}/rest/api/3/issue")

            JIRA_KEY=$(echo "$RESPONSE" | jq -r .key)
            if [ "$JIRA_KEY" = "null" ] || [ -z "$JIRA_KEY" ]; then
              echo "Failed to create Jira issue. Response:"
              echo "$RESPONSE"
              continue
            fi
            echo "Created Jira epic: $JIRA_KEY"

            # Now update the GitHub Project item field via GraphQL
            echo "Updating GitHub Project item $ITEM_ID field $JIRA_FIELD_ID with $JIRA_KEY"

            MUTATION='mutation UpdateField($input: UpdateProjectV2ItemFieldValueInput!) { updateProjectV2ItemFieldValue(input: $input) { projectV2Item { id } } }'
            VARIABLES=$(jq -n \
              --arg projectId "$PROJECT_ID" \
              --arg itemId "$ITEM_ID" \
              --arg fieldId "$JIRA_FIELD_ID" \
              --arg jiraKey "$JIRA_KEY" \
              '{ input: { projectId: $projectId, itemId: $itemId, fieldId: $fieldId, value: { text: $jiraKey } } }')

            GITHUB_RESPONSE=$(curl -s -X POST https://api.github.com/graphql \
              -H "Authorization: Bearer ${GH_TOKEN}" \
              -H "Content-Type: application/json" \
              -d "$(jq -n --arg q "$MUTATION" --argjson v "$VARIABLES" '{query: $q, variables: $v}')" )

            echo "GitHub response: $GITHUB_RESPONSE"
            echo "Done for item $ITEM_ID"

            # small delay to be polite to APIs
            sleep 1
          done

          echo "All done."
        env:
          JIRA_BASE_URL: ${{ env.JIRA_BASE_URL }}
          JIRA_EMAIL: ${{ env.JIRA_EMAIL }}
          JIRA_API_TOKEN: ${{ env.JIRA_API_TOKEN }}
          GH_TOKEN: ${{ env.GH_TOKEN }}
          JIRA_PROJECT_KEY: ${{ env.JIRA_PROJECT_KEY }}
